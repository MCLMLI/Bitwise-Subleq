# BS (Bitwise Subleq)

中文 | [English](README_EN.md)

**一种仅使用二进制编码的极简图灵完备编程语言**

BS (Bitwise Subleq) 是一门实验性编程语言，以最极简的设计实现图灵完备：双字符字母表 {0, 1}、自终止地址编码和单指令架构（Subleq）。它是研究计算理论与编程本质的有力工具。

## 目录

- [语言概述](#语言概述)
- [语言规范](#语言规范)
- [实现](#实现)
- [许可证](#许可证)

## 语言概述

### 核心特性

- **字符集**: `{0, 1}` - 纯二进制
- **最小单元**: bit（比特）
- **词汇单元**: 6位块（4位数据 + 1位功能位 + 1位链接标志）
- **指令集**: 单指令（Subleq - 相减并在小于等于零时跳转）
- **内存模型**: 支持任意寻址的稀疏内存
- **图灵完备**: 可计算任何可计算函数

### 设计哲学

BS 探索一个问题："实现计算的绝对最小需求是什么？" 通过剥离所有不必要的复杂性，BS 证明了：
- 复杂计算只需要减法和条件分支
- 自终止变长编码能够高效表示数据
- 两个符号足以实现任何算法

## 语言规范

### 1. 自终止地址编码（新格式）

每个地址由一个或多个6位块组成：`[dddd][s][l]`

- **dddd**: 4位数据位（高位在前，**总是累积到地址**）
- **s**: 功能位（**不作为数据**，仅作标记）
- **l**: 链接位（**不作为数据**，控制是否继续读取）

#### 解析规则：

**数据累积**：
- 每个段的4位数据（dddd）**总是**被解析并累积到地址值
- 地址 = (address << 4) | data，不断左移累积

**功能位（s）**：
- **s=0**: 该段没有功能位标记
- **s=1且l=0**: 该段有功能位标记（有效）
- **s=1且l=1**: 错误情况，视为s=0处理

**链接位（l）**：
- **l=0**: 地址解析结束
- **l=1**: 继续读取下一个6位块

**示例:**
```
比特流: 000010
        ↓
段:     0000(数据) 1(功能) 0(链接)

解析过程:
- 数据位 0000 = 0
- 功能位 s=1, 链接位 l=0 → 有功能位，地址结束
- 结果: 地址=0, hasFunction=true
```

```
比特流: 000110 010010
        ↓       ↓
段1:    0001 s=1 l=0 (有功能位，地址结束)
段2:    不会被读取

解析过程:
- 段1: 数据=0001=1, s=1, l=0 → 有功能位，结束
- 结果: 地址=1, hasFunction=true
```

```
比特流: 00011 001110
        ↓      ↓
段1:    0001 s=1 l=1 (错误！s=1且l=1)
段2:    0011 s=1 l=0 (有功能位)

解析过程:
- 段1: 数据=0001=1累积，s=1但l=1→错误，视为无功能位，继续
- 段2: 数据=0011=3累积，s=1且l=0→有功能位，结束
- 结果: 地址=(1<<4)|3=19, hasFunction=true
```

### 2. 指令格式

每条指令由三个连续的地址组成：

```
指令 = [地址a][地址b][地址c]
```

**执行语义:**
```
// 在同一条指令内，按顺序检查并执行所有功能位
// 注意：所有功能位操作都在同一条指令内完成，不会中途返回

// 1. 检查a段功能位（输入）
if (a段功能位 == 1)
    从输入读取1字节 → mem[a]
    // 继续执行后续功能位检查

// 2. 检查b段功能位（输出）
if (b段功能位 == 1)
    输出 mem[b] 的低8位
    // 继续执行后续功能位检查

// 3. 检查c段功能位（停机）
if (c段功能位 == 1)
    停机并退出
    return

// 4. 如果有任何功能位被触发
if (a段功能位 == 1 || b段功能位 == 1 || c段功能位 == 1)
    PC = PC + 1
    return  // 不执行Subleq指令

// 5. 否则执行正常的Subleq指令
mem[b] = mem[b] - mem[a]
if (mem[b] <= 0)
    PC = c
else
    PC = PC + 1
```

**重要说明：**
- 在同一条指令内，a段、b段、c段的功能位会**按顺序全部执行**（如果被设置）
- 例如：`000010 000010 000000` 会先输入到mem[0]，然后立即输出mem[0]，最后PC+1
- 只要有任何功能位被触发，就不会执行正常的Subleq减法运算

### 3. 功能位特殊操作

功能位提供了不依赖特殊地址值的I/O和控制操作：

| 段 | 功能位=1时的行为 | 描述 |
|------|------|------|
| **a段** | 阻塞输入 | 从标准输入读取1字节到 `mem[a]` 地址，然后PC+1 |
| **b段** | 输出 | 将 `mem[b]` 地址的内容（低8位）输出到标准输出，然后PC+1 |
| **c段** | 停机 | 立即终止程序执行 |

**优势：** 不再依赖特殊地址值（如全1），而是使用明确的功能位标记，避免了地址空间的特殊保留。

### 4. 内存模型

- 使用哈希表实现的稀疏内存
- 所有未初始化地址默认为0
- 支持任意正整数地址
- 理论上无限的地址空间

### 5. 程序计数器

- 从地址0开始
- 指令顺序执行，除非发生跳转
- 当c段功能位为1时程序终止

## 快速入门

### 示例程序

#### 立即停机
```
000010 000010 000010
#  a     b     c
# a=0, b=0, c=0
# c段功能位=1，立即停机
```

#### 简单输出
```
# 假设mem[0]已包含字符'A'(65)
000000 000010 000010
# a=0(无功能), b=0(输出), c=0(停机)
# b段功能位=1: 输出mem[0]
# c段功能位=1: 停机
```

#### 输入并输出（回显）
```
000010 000010 000010
# a=0(输入), b=0(输出), c=0(停机)
# a段功能位=1: 输入到mem[0]
# b段功能位=1: 输出mem[0]
# c段功能位=1: 停机
```

**运行方式：**
```bash
# 使用管道输入（推荐）
echo A | java -jar Bitwise-Subleq-Interpreter-Java-1.0-SNAPSHOT.jar -e "000010000010000010"

# 或使用文件输入
echo ABC > input.txt
java -jar Bitwise-Subleq-Interpreter-Java-1.0-SNAPSHOT.jar -f program.bs < input.txt
```

#### 多段地址示例
```
000111 001110 000010 000010
# a段: 0001 s=1 l=1 → 继续
#      0011 s=1 l=0 → 地址=19, 有功能位(输入)
# b段: 0000 s=1 l=0 → 地址=0, 有功能位(输出)
# c段: 0000 s=1 l=0 → 地址=0, 有功能位(停机)
# 功能: 输入到mem[19]，输出mem[0]，停机
```

## 实现

### Java 解释器

我们提供了功能完整的 Java 解释器实现。

📦 **推荐：使用预编译版本**

从 [Releases](https://github.com/MCLMLI/Bitwise-Subleq/releases) 页面下载最新的 `Bitwise-Subleq-Interpreter-Java-x.x.x.jar`

```bash
# 下载后直接运行
java -jar Bitwise-Subleq-Interpreter-Java-1.0-SNAPSHOT.jar -e "000010000010000010"

# 查看帮助
java -jar Bitwise-Subleq-Interpreter-Java-1.0-SNAPSHOT.jar --help
```

📖 详细文档：[Java解释器 README](Interpreter/Java/README.md)

## 许可证

本项目采用 [GNU Affero General Public License v3.0](LICENSE) 开源。

---

**© 2025 BS (Bitwise Subleq) Project**  
使用本软件即表示您同意遵守 AGPLv3 许可证的所有条款。
