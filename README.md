# BS (Bitwise Subleq)

中文 | [English](README_EN.md)

**一种仅使用二进制编码的极简图灵完备编程语言**

BS (Bitwise Subleq) 是一门实验性编程语言，以最极简的设计实现图灵完备：双字符字母表 {0, 1}、自终止地址编码和单指令架构（Subleq）。它是研究计算理论与编程本质的有力工具。

## 语言概述

### 核心特性

- **字符集**: `{0, 1}` - 纯二进制
- **最小单元**: bit（比特）
- **词汇单元**: 6位块（4位数据 + 1位功能位 + 1位链接标志）
- **指令集**: 单指令（Subleq - 相减并在小于等于零时跳转）
- **内存模型**: 支持任意寻址的稀疏内存
- **图灵完备**: 可计算任何可计算函数

### 设计哲学

BS 探索一个问题："实现计算的绝对最小需求是什么？" 通过剥离所有不必要的复杂性，BS 证明了：
- 复杂计算只需要减法和条件分支
- 自终止变长编码能够高效表示数据
- 两个符号足以实现任何算法

## 语言规范

### 1. 自终止地址编码（新格式）

每个地址由一个或多个6位块组成：`[dddd][s][l]`

- **dddd**: 4位数据位（高位在前）
- **s**: 功能位
- **l**: 链接位

#### 解析规则：

1. **s=0**（功能位为0）：丢弃该段，不解析数据
   - 如果 l=0：地址解析结束
   - 如果 l=1：继续读取下一段

2. **s=1, l=0**（功能位为1，链接位为0）：有效段
   - 解析数据位并累积到地址
   - 地址解析结束
   - 该段具有功能位标记

3. **s=1, l=1**（功能位为1，链接位为1）：错误情况
   - 视为 s=0 处理（丢弃该段）
   - 地址解析结束

**示例:**
```
比特流: 000110 010010
        ↓       ↓
段1:    0001 s=1 l=0 (有效段，地址结束)
段2:    不会被读取

结果: 地址=0001₂ = 1₁₀, hasFunction=true
```

```
比特流: 010011 100110
        ↓       ↓
段1:    0100 s=1 l=1 (错误！视为s=0)
地址解析结束

结果: 地址=0₁₀, hasFunction=false
```

### 2. 指令格式

每条指令由三个连续的地址组成：

```
指令 = [地址a][地址b][地址c]
```

**执行语义:**
```
// 首先检查功能位
if (c段功能位 == 1)
    停机并退出

if (a段功能位 == 1)
    从输入读取1字节 → mem[a]
    PC = PC + 1
    return

if (b段功能位 == 1)
    输出 mem[b] 的低8位
    PC = PC + 1
    return

// 正常Subleq指令
mem[b] = mem[b] - mem[a]
if (mem[b] <= 0)
    PC = c
else
    PC = 下一条指令
```

### 3. 功能位特殊操作

功能位提供了不依赖全1编码的I/O和控制操作：

| 段 | 功能位=1时的行为 | 描述 |
|------|------|------|
| **a段** | 阻塞输入 | 从标准输入读取1字节到 `mem[a]` 地址，然后PC+1 |
| **b段** | 输出 | 将 `mem[b]` 地址的内容（低8位）输出到标准输出，然后PC+1 |
| **c段** | 停机 | 立即终止程序执行 |

**优势：** 不再使用全1编码（容易误判），而是使用明确的功能位标记。

### 4. 内存模型

- 使用哈希表实现的稀疏内存
- 所有未初始化地址默认为0
- 支持任意正整数地址
- 理论上无限的地址空间

### 5. 程序计数器

- 从地址0开始
- 指令顺序执行，除非发生跳转
- 当c段功能位为1时程序终止

## 快速入门

### 示例程序

#### 立即停机
```
000010 000010 000010
#  a     b     c
# c段功能位=1，立即停机
```

#### 输出字符
```
# 假设mem[5]已包含字符'A'(65)
010110 000010 000010
#  a=5   b=0   c=0
#       输出   停机
# b段功能位=1: 输出mem[0]
# c段功能位=1: 停机
```

#### 输入并输出
```
000110 000110 000010
# a功能位=1: 输入到mem[0]
# b功能位=1: 输出mem[0]  
# c功能位=1: 停机
```

## 实现版本

### Java 解释器

功能完整的解释器，支持调试模式和新的功能位编码。

**位置**: `Interpreter/Java/`

**快速开始**:
```bash
cd Interpreter/Java\src\main\java
javac -encoding UTF-8 *.java
java BSMain -e "000010000010000010"  # 测试停机
java BSMain -d -e "你的比特流"        # 调试模式
```

详细用法请参阅 [Java README](Interpreter/Java/README.md)。

## 应用场景

### 教育用途

- **计算理论**: 用最少组件演示图灵完备性
- **编译器设计**: 研究指令编码和解码
- **算法设计**: 在约束下培养创造性问题解决能力

### 研究用途

- **极简计算**: 探索计算极简主义的边界
- **编码理论**: 研究自终止可变长度编码
- **理论计算机科学**: 研究Subleq架构变体

### 艺术用途

- **深奥编程**: 加入极简语言家族（Brainfuck、Malbolge等）
- **二进制艺术**: 用可执行代码创建视觉模式
- **生成艺术**: 利用计算约束进行创意输出

## 语言对比

| 特性 | BS | Brainfuck | OISC | 机器码 |
|------|----|-----------|----- |--------|
| 字符集大小 | 2 | 8 | 可变 | 256 |
| 指令数 | 1 | 8 | 1 | 100+ |
| 地址编码 | 变长(6位块) | 固定 | 固定 | 固定 |
| I/O方式 | 功能位 | 专用指令 | 特殊地址 | 专用指令 |
| 图灵完备 | ✓ | ✓ | ✓ | ✓ |

## 技术优势

1. **最小化解析**: 只需识别6位块
2. **自描述**: 地址长度由内容决定
3. **功能位机制**: 避免全1误判问题
4. **紧凑小值**: 常见地址（0-15）仅用6位
5. **无界地址**: 没有人为的内存限制
6. **硬件友好**: 易于在数字电路中实现

## 贡献指南

我们欢迎各种形式的贡献：

- **新实现**: 用其他语言编写解释器
- **示例程序**: 创建有趣的BS程序
- **优化**: 提高性能或减小代码大小
- **文档**: 改进解释和教程
- **工具**: 汇编器、调试器、可视化工具

## 项目结构

```
Bitwise-Subleq/
├── README.md           # 本文件（中文）
├── README_EN.md        # 英文文档
├── LICENSE             # 许可证信息
└── Interpreter/        # 语言实现
    └── Java/           # Java解释器
        ├── README.md   # 实现文档（中文）
        ├── README_EN.md # 实现文档（英文）
        └── src/        # 源代码
```

## 许可证

本项目采用 MIT 许可证 - 详见 [LICENSE](LICENSE) 文件

## 联系方式

- **Issues**: 在GitHub上提交问题
- **Pull Requests**: 欢迎贡献代码

---

**BS (Bitwise Subleq)** - 探索计算的本质，从0和1开始。
