# BS (Bitwise Subleq)

中文 | [**English**](README_EN.md)

**一种只用 0 和 1 就能编写任何程序的极简编程语言**

---

## 📚 目录

- [什么是 BS？](#什么是-bs)
- [5 分钟快速上手（适合初级用户）](#5-分钟快速上手)
- [深入理解 BS 语言（适合中级用户）](#深入理解-bs-语言)
- [完整语言规范（适合高级用户）](#完整语言规范)
- [常见问题解答](#常见问题解答)
- [开源协议](#开源协议)

---

## 什么是 BS？

### 给完全新手的解释

想象一下莫尔斯电码 —— 它只用"点"和"划"两个符号就能表达所有字母。BS 语言也是这样的想法，但更极端：**它只用 0 和 1 两个符号，就能编写任何计算机程序**！

比如：
- 计算器程序
- 文字处理软件
- 甚至是操作系统

都可以用一串 0 和 1 来编写（虽然会非常非常长）。

### 给有编程经验者的解释

BS (Bitwise Subleq) 是一个基于 **单指令集架构 (OISC)** 的图灵完备编程语言：

- **字符集**：仅有 `{0, 1}` 两个符号
- **指令**：仅有 Subleq（相减并条件跳转）一种指令
- **编码**：自终止变长地址编码
- **内存**：稀疏内存模型（哈希表实现）

这是一个研究**计算本质**的实验性语言，证明了即使用最简单的元素，也能构建完整的计算系统。

---

## 5 分钟快速上手

### 步骤 1：下载解释器

1. 访问 [发布页面](https://github.com/MCLMLI/Bitwise-Subleq/releases)
2. 下载 `Bitwise-Subleq-Interpreter-Java-1.0.jar` 文件
3. 保存到你的电脑（任意文件夹）

### 步骤 2：安装 Java

如果你还没有安装 Java：
- 访问 [java.com](https://www.java.com/)
- 下载并安装 Java
- 安装后，打开命令行输入 `java -version` 验证

### 步骤 3：运行你的第一个程序

打开命令行（Windows 按 `Win+R` 输入 `cmd`，Mac/Linux 打开终端），输入：

```bash
# 程序1：立即停止（最简单的程序）
java -jar Bitwise-Subleq-Interpreter-Java-1.0.jar -e "000010000010000010"
```

**结果**：程序立即结束，什么都不做。

```bash
# 程序2：回显（重复你输入的内容）
echo ABC | java -jar Bitwise-Subleq-Interpreter-Java-1.0.jar -e "000010000010000000000010000010000000000010000010000010"
```

**结果**：屏幕显示 `ABC`

🎉 **恭喜！你已经成功运行了 BS 程序！**

> 💡 查看更多命令：`java -jar Bitwise-Subleq-Interpreter-Java-1.0.jar -h`

---

## 深入理解 BS 语言

### 1. BS 程序的基本结构

一个 BS 程序就是一串 0 和 1，比如：
```
000010 000010 000010
```

这串数字被分成**三段**（用空格分开只是为了方便阅读，实际可以连在一起）：
- 第一段 `000010` - 我们叫它 **a 段**
- 第二段 `000010` - 我们叫它 **b 段**  
- 第三段 `000010` - 我们叫它 **c 段**

这三段合起来叫做一条**指令**。

### 2. 每段是什么意思？

每一段都是 6 位（6 个 0 或 1），分成三个部分：

```
0 0 0 0    0     0
└─数据─┘ └功能┘ └链接┘
  4位    1位   1位
```

#### 2.1 数据位（前 4 位）

这是一个**地址**，告诉程序去哪个"格子"读写数据。

想象内存是一排格子：
```
格子编号：  0    1    2    3    4  ...
内容：    [42] [0]  [65] [0]  [0] ...
```

前 4 位 `0000` 表示地址 0，`0001` 表示地址 1，依此类推。

**举例**：
- `0000` = 地址 0
- `0001` = 地址 1
- `0010` = 地址 2
- `1111` = 地址 15

#### 2.2 功能位（第 5 位）

这一位很特殊，它决定这段有没有**特殊功能**：
- `0` = 没有特殊功能
- `1` = 有特殊功能（具体是什么功能，取决于是 a、b 还是 c 段）

#### 2.3 链接位（第 6 位）

这一位决定地址是否**继续**：
- `0` = 这段结束了
- `1` = 还要读下一个 6 位块（用于表示大地址）

### 3. 三段的特殊功能

当功能位 = 1 时，三段有不同的超能力：

| 段 | 功能位=1 时的超能力 | 通俗解释 |
|----|-------------------|----------|
| **a 段** | 🎤 **输入** | 等待你输入一个字符，保存到指定地址 |
| **b 段** | 📢 **输出** | 把指定地址的内容显示在屏幕上 |
| **c 段** | 🛑 **停止** | 程序结束运行 |

### 4. 完整示例解析

#### 示例 1：立即停止程序

```
000010 000010 000010
```

**逐段解析**：

1. **a 段** `000010`：
   - 数据 `0000` = 地址 0
   - 功能 `1` = 有输入功能
   - 链接 `0` = 段结束

2. **b 段** `000010`：
   - 数据 `0000` = 地址 0
   - 功能 `1` = 有输出功能
   - 链接 `0` = 段结束

3. **c 段** `000010`：
   - 数据 `0000` = 地址 0
   - 功能 `1` = 有停止功能 ⚠️
   - 链接 `0` = 段结束

**执行过程**：
1. a 段：等待输入一个字符，保存到地址 0
2. b 段：输出地址 0 的内容（刚才输入的字符）
3. c 段：**停止程序** ✋

**运行效果**：
```bash
$ echo A | java -jar interpreter.jar -e "000010000010000010"
A
```
输入字母 A，程序立即输出 A 后停止。

#### 示例 2：连续回显 3 个字符

```
000010000010000000 000010000010000000 000010000010000010
└──────指令1──────┘└──────指令2──────┘└──────指令3──────┘
```

- **指令 1**：输入 → 输出 → 继续
- **指令 2**：输入 → 输出 → 继续  
- **指令 3**：输入 → 输出 → 停止

**运行效果**：
```bash
$ echo ABC | java -jar interpreter.jar -e "程序代码"
ABC
```

### 5. 大地址的表示方法

如果你需要访问更大的地址（超过 15），可以用**链接位**把多个 6 位块连起来：

```
000111  001110
└─块1─┘ └─块2─┘
```

**块 1** `000111`：
- 数据 `0001` = 1
- 功能 `1`
- 链接 `1` = ⚠️ 继续读下一块

**块 2** `001110`：
- 数据 `0011` = 3
- 功能 `1`
- 链接 `0` = 结束

**最终地址** = (1 × 16) + 3 = **19**

**运行效果** ：将输入的字符写入地址为 **19** 的内存中

> 📖 **规则**：当功能位=1 且链接位=1 时，是错误情况，会被当作功能位=0 处理，但数据仍然累积。

### 6. 没有功能位时会怎样？

如果一条指令的 a、b、c 三段**都没有功能位**（全是 0），那么会执行标准的 **Subleq 指令**：

```python
# Subleq 指令的伪代码
mem[b] = mem[b] - mem[a]  # 从 b 地址的值中减去 a 地址的值
if mem[b] <= 0:
    跳转到 c 地址继续执行
else:
    继续执行下一条指令
```

**通俗解释**：
1. 把地址 b 的数减去地址 a 的数
2. 如果结果 ≤ 0，就跳到地址 c
3. 否则继续下一条

这就是 BS 语言的**唯一计算指令**！所有复杂的运算都要用这个指令组合实现。

---

## 完整语言规范

<details>
<summary><b>📖 点击展开完整技术规范（适合高级用户）</b></summary>

### 核心特性总结

| 特性 | 说明 |
|------|------|
| 字符集 | `{0, 1}` - 纯二进制 |
| 最小单元 | bit（比特） |
| 词汇单元 | 6 位块 `[dddd][s][l]` |
| 指令集 | 单指令（Subleq） |
| 内存模型 | 稀疏内存（HashMap 实现） |
| 图灵完备 | ✅ 是 |

### 1. 地址编码完整规则

#### 1.1 单块地址

```
格式：[dddd][s][l]
      │    │  └─ 链接位 (0=结束, 1=继续)
      │    └──── 功能位 (0=无功能, 1=有功能)
      └───────── 4位数据 (地址值)
```

**编码表**：

| 二进制 | 十进制地址 | 有功能？ |
|--------|----------|---------|
| `000000` | 0 | ❌ |
| `000010` | 0 | ✅ |
| `000100` | 1 | ❌ |
| `000110` | 1 | ✅ |
| `111100` | 15 | ❌ |
| `111110` | 15 | ✅ |

#### 1.2 多块地址（大地址）

当需要表示地址 ≥ 16 时，使用多块：

```
地址 = 0
for 每个 6 位块:
    地址 = (地址 << 4) | 数据位
```

**示例：地址 255**

```
步骤1：11110 (15, 链接=1) → 地址 = 15
步骤2：11110 (15, 链接=0) → 地址 = 15×16 + 15 = 255
```

#### 1.3 功能位与链接位的组合规则

| 功能位 | 链接位 | 结果 |
|-------|-------|------|
| `0` | `0` | ✅ 无功能，段结束 |
| `0` | `1` | ✅ 无功能，继续下一块 |
| `1` | `0` | ✅ 有功能，段结束 |
| `1` | `1` | ⚠️ **错误**，视为无功能，继续 |

**重要**：`s=1 且 l=1` 是非法组合，会被当作 `s=0, l=1` 处理。

### 2. 指令执行流程

#### 2.1 完整执行顺序

```
1. 读取 a 段地址和功能位
2. 读取 b 段地址和功能位
3. 读取 c 段地址和功能位

4. 按顺序检查功能位：
   if (a_func):
       mem[a] = 从标准输入读取 1 字节
   
   if (b_func):
       输出 mem[b] 的低 8 位到标准输出
   
   if (c_func):
       停机
       return

5. 如果有任何功能位被触发：
   PC = PC + 1
   return

6. 否则执行 Subleq 指令：
   mem[b] = mem[b] - mem[a]
   if (mem[b] <= 0):
       PC = c
   else:
       PC = PC + 1
```

#### 2.2 关键特性

- **原子性**：一条指令的所有功能位在同一时刻执行
- **顺序性**：a → b → c 按顺序检查
- **互斥性**：有功能位时不执行 Subleq 运算

### 3. 内存模型

```java
// Java 实现
Map<Integer, Integer> memory = new HashMap<>();

int read(int address) {
    return memory.getOrDefault(address, 0);
}

void write(int address, int value) {
    memory.put(address, value);
}
```

**特性**：
- 所有地址默认值为 0
- 支持任意正整数地址
- 值为 32 位有符号整数

### 4. 程序计数器（PC）

- **初始值**：0
- **正常递增**：`PC = PC + 1`
- **条件跳转**：当 `mem[b] ≤ 0` 时 `PC = c`
- **停机条件**：
  - c 段功能位 = 1
  - PC 超出程序范围
  - 执行指令数超过限制（默认 1,000,000）

### 5. 输入输出详解

#### 5.1 输入（a 段功能位 = 1）

```
行为：mem[a] = getchar()
```

- 从标准输入读取**1 个字节**
- 阻塞式读取（会等待输入）
- EOF 时返回 0

**终端行缓冲特性**：

大多数终端是**行缓冲**的：
```
用户操作：输入 "ABC" + 回车
缓冲区：['A', 'B', 'C', '\n']
程序行为：连续 4 次 read() 依次返回这 4 个字符
```

**解决方案**：
```bash
# 方法1：使用管道
echo ABC | java -jar interpreter.jar program.bs

# 方法2：使用重定向
java -jar interpreter.jar program.bs < input.txt
```

#### 5.2 输出（b 段功能位 = 1）

```
行为：putchar(mem[b] & 0xFF)
```

- 输出 `mem[b]` 的**低 8 位**
- 立即刷新缓冲区
- 对应 ASCII 字符

**示例**：
```
mem[5] = 65  → 输出 'A'
mem[5] = 72  → 输出 'H'
mem[5] = 256 → 输出 '\0' (256 & 0xFF = 0)
```

#### 5.3 无缓冲输入（高级特性）

Java 解释器支持基于 JNA 的真正逐字符输入：

**Windows**：
```c
SetConsoleMode(hStdin, mode & ~(ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT));
```

**Linux/Mac**：
```c
struct termios new_termios = old_termios;
new_termios.c_lflag &= ~(ICANON | ECHO);
tcsetattr(STDIN_FILENO, TCSANOW, &new_termios);
```

**效果**：
- ✅ 按键立即响应，无需回车
- ✅ 程序结束自动恢复终端
- ⚠️ 需要包含 JNA 的 fat JAR

### 6. 完整示例程序

#### 示例 1：无限回显

```
# 伪汇编表示
loop:
    000010 000010 000000  # 输入到地址0，输出地址0，跳转到自己
```

实际二进制（指向自己的循环需要精确计算地址）较复杂。

#### 示例 2：输出预设字符

假设地址 0 已经包含 ASCII 值 72（字母 'H'）：

```
000000 000010 000010
│      │      └─ c段：停机
│      └──────── b段：输出地址0
└───────────── a段：地址0，无功能
```

**执行**：
1. 无 a 功能位，跳过
2. b 功能位=1，输出地址 0 的内容（'H'）
3. c 功能位=1，停机

**输出**：`H`

</details>

---

## 常见问题解答

### Q1: BS 真的能写任何程序吗？

**答**：理论上是的！

BS 基于 **Subleq** 指令，这是已被数学证明的**图灵完备**架构。意味着它可以计算任何"可计算"的函数，包括：
- ✅ 计算器
- ✅ 文本编辑器
- ✅ 编译器
- ✅ 操作系统
- ✅ 游戏

但实际编写会**极其复杂**，因为你只有减法和跳转两种操作。

### Q2: BS 有什么实际用途？

**主要用途**：

1. **教育**：理解计算机的本质原理
   - 了解什么是"图灵完备"
   - 理解指令集架构
   - 学习编译原理

2. **研究**：探索计算的极限
   - 最小指令集研究
   - 编码理论
   - 复杂性理论

3. **挑战**：程序员的脑力训练
   - Esoteric programming（深奥编程）社区
   - Code Golf 竞赛

4. **艺术**：代码即艺术
   - 用最简单的元素创造复杂系统

### Q3: 如何编写复杂的 BS 程序？

**直接手写**：几乎不可能 ❌

**推荐方法**：

1. **编写汇编器**
   ```
   设计一种更高级的 BS 汇编语言
   ↓
   写个程序把汇编翻译成 BS 二进制
   ```

2. **编写编译器**
   ```
   用 C/Python/Java 等语言
   ↓
   写个编译器生成 BS 代码
   ```

3. **使用代码生成器**
   ```python
   # Python 示例
   def gen_output(char_code, addr=0):
       return f"{'0'*4}0{addr:04b}0 {char_code:04b}10 000010"
   ```

**欢迎贡献工具到本项目！**

### Q4: 为什么叫 "Bitwise Subleq"？

- **Bitwise**（按位）：因为程序是纯二进制比特流
- **Subleq**：Subtract and branch if Less than or Equal（相减并在小于等于时跳转）

名字直接描述了语言的两大特征。

### Q5: 和其他 Esoteric 语言相比如何？

| 语言 | 字符集 | 指令数 | 特点 |
|------|-------|-------|------|
| **BS** | 2 | 1 | 最小化设计，二进制 |
| Brainfuck | 8 | 8 | 经典，相对易懂 |
| Malbolge | 94 | 3 | 故意设计得难用 |
| Whitespace | 3 | 24 | 只用空格、制表、换行 |

BS 的特点是**真正的最小化**，只用两个符号和一种指令。

---

## 开源协议

本项目使用 **[GNU Affero General Public License v3.0 (AGPL-3.0)](LICENSE)** 开源。

### 简单说明

✅ **你可以**：
- 免费使用、学习、修改
- 用于个人或商业项目
- 分发你的修改版本

⚠️ **你必须**：
- 开源你的修改（如果分发）
- 保留原作者版权声明
- 使用相同的 AGPL-3.0 协议
- **如果做成网络服务**（如 Web API），也必须开源服务器代码

### 为什么选择 AGPL？

AGPL 是 GPL 的加强版，堵住了"SaaS 漏洞"：

**场景对比**：
```
GPL：我修改你的代码 → 做成网站服务 → 赚钱 → 不开源 ❌
AGPL：我修改你的代码 → 做成网站服务 → 必须向用户提供源码 ✅
```

这确保 BS 生态系统保持**完全开放**。

### 详细条款

请阅读 [LICENSE](LICENSE) 文件了解完整法律条款。

---

## 相关资源

### 📚 文档

- **Java 解释器使用指南**：[中文](Interpreter/Java/README.md) | [English](Interpreter/Java/README_EN.md)
- **项目主页**：https://github.com/MCLMLI/Bitwise-Subleq
- **问题反馈**：https://github.com/MCLMLI/Bitwise-Subleq/issues
- **版本发布**：https://github.com/MCLMLI/Bitwise-Subleq/releases

### 🔗 相关项目

- [Subleq - Esolang Wiki](https://esolangs.org/wiki/Subleq) - Subleq 语言详解
- [OISC - Wikipedia](https://en.wikipedia.org/wiki/One-instruction_set_computer) - 单指令集计算机
- [Esoteric Programming Languages](https://esolangs.org/) - 深奥编程语言社区

### 🤝 贡献

欢迎贡献！特别需要：

- 📝 示例程序（尤其是有趣的程序）
- 🛠️ 其他语言的解释器（Python、C、Rust 等）
- 🔧 开发工具（汇编器、调试器、可视化工具）
- 📖 教程和文档改进
- 🐛 Bug 报告和修复
- 🌍 翻译（其他语言版本）

提交方式：
1. Fork 本仓库
2. 创建你的特性分支
3. 提交 Pull Request

或者直接 [创建 Issue](https://github.com/MCLMLI/Bitwise-Subleq/issues) 讨论想法。

---

## 致谢

感谢所有为本项目做出贡献的人！

---

<div align="center">

### ⭐ 如果你觉得这个项目有趣，请给个 Star！

**让更多人发现 BS 语言的魅力**

---

Made with ❤️ by curious minds

*探索计算的本质，体验编程的纯粹*

</div>
