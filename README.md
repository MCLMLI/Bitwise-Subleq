# BS (Bitwise Subleq)

**一种仅使用二进制编码的极简图灵完备编程语言**

BS (Bitwise Subleq) 是一门实验性编程语言，以最极简的设计实现图灵完备：双字符字母表 {0, 1}、自终止地址编码和单指令架构（Subleq）。它是研究计算理论与编程本质的有力工具。

## 语言概述

### 核心特性

- **字符集**: `{0, 1}` - 纯二进制
- **最小单元**: bit（比特）
- **词汇单元**: 5位块（4位数据 + 1位链接标志）
- **指令集**: 单指令（Subleq - 相减并在小于等于零时跳转）
- **内存模型**: 支持任意寻址的稀疏内存
- **图灵完备**: 可计算任何可计算函数

### 设计哲学

BS 探索一个问题："实现计算的绝对最小需求是什么？" 通过剥离所有不必要的复杂性，BS 证明了：
- 复杂计算只需要减法和条件分支
- 自终止变长编码能够高效表示数据
- 两个符号足以实现任何算法

## 语言规范

### 1. 自终止地址编码

每个地址由一个或多个5位块组成：`[dddd][l]`

- **dddd**: 4位数据位（高位在前）
- **l**: 链接位
  - `0` = 地址结束
  - `1` = 继续读取下一块（数据左移4位）

**示例:**
```
比特流: 10011 01000
        ↓      ↓
段1:    1001 (链接=1，继续)
段2:    0100 (链接=0，结束)

结果: (1001 << 4) | 0100 = 10010100₂ = 148₁₀
```

这种编码允许任意大小的地址，同时保持小地址的紧凑性。

### 2. 指令格式

每条指令由三个连续的地址组成：

```
指令 = [地址a][地址b][地址c]
```

**执行语义:**
```
mem[b] = mem[b] - mem[a]
if (mem[b] <= 0)
    PC = c
else
    PC = 下一条指令
```

就是这样 - 这就是全部指令集！

### 3. 特殊地址 -1

当所有位都是1（`11111 11111 ...`）时，地址等于-1，触发特殊行为：

| 操作 | 条件 | 行为 |
|------|------|------|
| **输出** | `b == -1` 且 `a ≠ -1` | 输出 `mem[a] & 0xFF` 作为字符 |
| **输入** | `a == -1` 且 `b == -1` | 从输入读取一个字节到 `mem[b]` |
| **停机** | `c == -1` 且 `mem[b] ≤ 0` | 终止程序执行 |

### 4. 内存模型

- 使用哈希表实现的稀疏内存
- 所有未初始化地址默认为0
- 支持负地址（用于I/O操作）
- 理论上无限的地址空间

### 5. 程序计数器

- 从地址0开始
- 指令顺序执行，除非发生跳转
- 跳转到-1时程序终止

## 快速入门

### 示例程序

#### Hello World（概念）
```
# 在内存中存储 'H' (72) 并输出
[addr_H][addr_output][-1]
# 对 'e', 'l', 'l', 'o' 继续...
```

#### 无限循环
```
000000000000000
# 解码: a=0, b=0, c=0
# 效果: mem[0] -= mem[0] → 总是0 → 跳转到0
```

#### 简单输出
```
100010000111111
# 从内存输出一个字符
```

## 实现版本

### Java 解释器

功能完整的解释器，支持调试。

**位置**: `Interpreter/Java/`

**快速开始**:
```bash
cd Interpreter/Java
.\gradlew.bat build              # Windows
java -cp build\classes\java\main BSMain -e 000000000000000
```

详细用法请参阅 [Java README](Interpreter/Java/README.md)。

### 未来实现

计划用其他语言实现：
- Python（教育重点）
- C（性能重点）
- WebAssembly（浏览器支持）

## 应用场景

### 教育用途

- **计算理论**: 用最少组件演示图灵完备性
- **编译器设计**: 研究指令编码和解码
- **算法设计**: 在约束下培养创造性问题解决能力

### 研究用途

- **极简计算**: 探索计算极简主义的边界
- **代码高尔夫**: 尺寸优化编程的终极挑战
- **理论计算机科学**: 研究Subleq架构变体

### 艺术用途

- **深奥编程**: 加入极简语言家族（Brainfuck、Malbolge等）
- **二进制艺术**: 用可执行代码创建视觉模式
- **生成艺术**: 利用计算约束进行创意输出

## 语言对比

| 特性 | BS | Brainfuck | OISC | 机器码 |
|------|----|-----------|----- |--------|
| 字符集大小 | 2 | 8 | 可变 | 256 |
| 指令数 | 1 | 8 | 1 | 100+ |
| 地址编码 | 变长 | 固定 | 固定 | 固定 |
| 图灵完备 | ✓ | ✓ | ✓ | ✓ |

## 技术优势

1. **最小化解析**: 只需识别5位块
2. **自描述**: 地址长度由内容决定
3. **紧凑小值**: 常见地址（0-15）仅用5位
4. **无界地址**: 没有人为的内存限制
5. **硬件友好**: 易于在数字电路中实现

## 贡献指南

我们欢迎各种形式的贡献：

- **新实现**: 用其他语言编写解释器
- **示例程序**: 创建有趣的BS程序
- **优化**: 提高性能或减小代码大小
- **文档**: 改进解释和教程
- **工具**: 汇编器、调试器、可视化工具

## 项目结构

```
Bitwise-Subleq/
├── README.md           # 本文件（中文）
├── README_EN.md        # 英文文档
├── LICENSE             # 许可证信息
└── Interpreter/        # 语言实现
    └── Java/           # Java解释器
        ├── README.md   # 实现文档（中文）
        ├── README_EN.md # 实现文档（英文）
        └── src/        # 源代码
```

## 学习资源

### 学习材料

- **Subleq架构**: 关于单指令计算的研究论文
- **变长编码**: 学习霍夫曼编码和自定界码
- **图灵完备性**: 理解通用计算

### 相关项目

- **Subleq**: 原始的单指令架构
- **Brainfuck**: 另一种极简语言
- **OISC (单指令集计算机)**: 极简架构家族

## 许可证

本项目为开源项目。详见 [LICENSE](LICENSE) 文件。

## 联系与社区

- **Issues**: 在GitHub上报告bug和请求功能
- **Discussions**: 分享想法和程序
- **Pull Requests**: 贡献代码和文档

---

**BS 语言** - *探索计算极简主义的极限*

*"简约是最高级的复杂。" - 列奥纳多·达·芬奇*
